<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.2.2">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2022-11-15T23:39:28-05:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Dark Corners of the API</title><subtitle>Dark Corners of the API, a place to talk about corners, edge cases, and poorly documented features of graphics APIs.
</subtitle><author><name>Nadav Geva</name></author><entry><title type="html">HLSL: Buffer vs. StructuredBuffer</title><link href="http://localhost:4000/buffers-vs-structuredbuffers" rel="alternate" type="text/html" title="HLSL: Buffer vs. StructuredBuffer" /><published>2022-11-15T21:00:00-05:00</published><updated>2022-11-15T21:00:00-05:00</updated><id>http://localhost:4000/buffers-vs-structuredbuffers</id><content type="html" xml:base="http://localhost:4000/buffers-vs-structuredbuffers">&lt;p&gt;Ever wondered why the DirectX offers two seemingly interchangeable buffer types? In this post we’ll go over the subtleties of the two. The MSDN does contain this information, but it is scattered across several pages that only vaguely link each other.&lt;/p&gt;

&lt;h3 id=&quot;buffer&quot;&gt;Buffer&lt;/h3&gt;
&lt;p&gt;The main purpose of a &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Buffer&lt;/code&gt; is to be used with a format. The template variable must fit in 4 32-bit quantities, but that template specifies the result after conversion &lt;strong&gt;not&lt;/strong&gt; the data as it is laid out in memory. The place that specifies the layout in memory is the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Format&lt;/code&gt; field of the SRV of the buffer. That’s right, even though a buffer resource must be created with &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DXGI_FORMAT_UNKNOWN&lt;/code&gt;, an SRV meant to be bound to an HLSL &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Buffer&lt;/code&gt; &lt;strong&gt;has&lt;/strong&gt; a format. That format also defines the stride of the buffer read, and therefore the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;StructureByteStride&lt;/code&gt; field of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;D3D12_BUFFER_SRV&lt;/code&gt; &lt;strong&gt;must&lt;/strong&gt; be 0. Currently, specifying a format and a non-0 stride can result in device removed by the D3D12 runtime.&lt;/p&gt;

&lt;p&gt;Here is a common example of where all of this comes in handy. You can store normals and tangents in a packed buffer, using 8 bit for the X and Y component of each vector (Z is implicit since they are normalized) and use an SRV with &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DXGI_FORMAT_R8G8B8A8_SNORM&lt;/code&gt; as the format. In the shader, you can bind this to a &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Buffer&amp;lt;float4&amp;gt;&lt;/code&gt; descriptor and when you load from the buffer the HW will convert the formats for you for free! It also works in the other direction as well. Declare a &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;RWBuffer&amp;lt;float4&amp;gt;&lt;/code&gt; in a shader, and stores will auto-magically be converted from &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;float4&lt;/code&gt; to &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;R8G8B8A8_SNORM&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Code snippet:&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Buffer&amp;lt;float4&amp;gt; NormalsAndTangents; // stored as RGBA8_snorm in memory
RWBuffer&amp;lt;float4&amp;gt; RW_NormalsAndTangents;

...
void main()
{
    float2 normal = NormalsAndTangents[idx].xy;
    float2 tangent = NormalsAndTangents[idx].zw;

    // do some math with the normals
    RW_NormalsAndTangents[idx] = float4(normal, tangent); // will be converted by the HW to RGBA8_snorm
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;structuredbuffer&quot;&gt;StructuredBuffer&lt;/h3&gt;
&lt;p&gt;A &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;StructuredBuffer&lt;/code&gt; is templated by a struct. Unlike &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Buffer&lt;/code&gt;, the template defines the layout in memory and conversions do not occur. You can still use simple types such as &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;float4&lt;/code&gt; or &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;int2&lt;/code&gt; but the data needs to be laid out in a matched way in memory(support for the 16-bit types however is shakier, a topic for another day). A &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;StructuredBuffer&lt;/code&gt; &lt;strong&gt;cannot&lt;/strong&gt; have a format, the SRV format needs to be &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DXGI_FORMAT_UNKNOWN&lt;/code&gt;. The &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;StructureByteStride&lt;/code&gt; field needs to be &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sizeof(struct)&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;This buffer is best used, well, for structs. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Light&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DrawPacket&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;BoneMatrix&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Particle&lt;/code&gt; etc. There isn’t really a limit on the size of the struct, but remember that everything in graphics tends to be multiplied by the screen resolution. If every pixel needs to read even just 8 bytes, that is 64MB for 4K target. Aligning the structs (and their members) to 16 byte boundaries will help performance as well. If you need a non-16 byte align type (a &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;float3&lt;/code&gt; for example) a better approach might be to declare it as &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Buffer&amp;lt;float&amp;gt;&lt;/code&gt; and access triplets in a shader. A bit ugly but will avoid some of the nasty edge cases of non-16 byte aligned types.&lt;/p&gt;

&lt;p&gt;Code snippet:&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;struct Particle
{
    float4 pos;
    float4 vel;
}

StructuredBuffer&amp;lt;Particle&amp;gt; ParticleArray; // stored as 2 float4 in memory
RWStructuredBuffer&amp;lt;Particle&amp;gt; RW_ParticleArray;

...
void main()
{
    Particle p = ParticleArray[idx];
    // do some math with the Particle
    RW_ParticleArray[idx] = p ; // no conversion will be stored as 2 float4
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;summary&quot;&gt;Summary&lt;/h2&gt;

&lt;p&gt;Here is a handy table to summarize the info:&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: left&quot;&gt; &lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Buffer&lt;/code&gt;&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;StructuredBuffer&lt;/code&gt;&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;Format for resource creation&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DXGI_FORMAT_UNKNOWN&lt;/code&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DXGI_FORMAT_UNKNOWN&lt;/code&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;Format for SRV\UAV&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;As laid out in memory&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DXGI_FORMAT_UNKNOWN&lt;/code&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;StructureByteStride&lt;/code&gt; field&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sizeof(struct)&lt;/code&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;Can convert data?&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Yes&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;No&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;If you found all of this confusing, you are not alone. We recently spent an hour debugging an issue with &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Buffer&lt;/code&gt; and incorrect format. And like most dark corners, the behavior between AMD and NV hardware is different…&lt;/p&gt;

&lt;p&gt;Some useful (?) MSDN pages:&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://learn.microsoft.com/en-us/windows/win32/api/d3d12/ns-d3d12-d3d12_unordered_access_view_desc&quot;&gt;https://learn.microsoft.com/en-us/windows/win32/api/d3d12/ns-d3d12-d3d12_unordered_access_view_desc&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://learn.microsoft.com/en-us/windows/win32/api/d3d12/ns-d3d12-d3d12_buffer_uav&quot;&gt;https://learn.microsoft.com/en-us/windows/win32/api/d3d12/ns-d3d12-d3d12_buffer_uav&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://learn.microsoft.com/en-us/windows/win32/api/d3d12/ns-d3d12-d3d12_shader_resource_view_desc&quot;&gt;https://learn.microsoft.com/en-us/windows/win32/api/d3d12/ns-d3d12-d3d12_shader_resource_view_desc&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://learn.microsoft.com/en-us/windows/win32/api/d3d12/ns-d3d12-d3d12_buffer_srv&quot;&gt;https://learn.microsoft.com/en-us/windows/win32/api/d3d12/ns-d3d12-d3d12_buffer_srv&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://learn.microsoft.com/en-us/windows/win32/direct3d12/typed-unordered-access-view-loads&quot;&gt;https://learn.microsoft.com/en-us/windows/win32/direct3d12/typed-unordered-access-view-loads&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://learn.microsoft.com/en-us/windows/uwp/graphics-concepts/shader-resource-view--srv-&quot;&gt;https://learn.microsoft.com/en-us/windows/uwp/graphics-concepts/shader-resource-view–srv-&lt;/a&gt;&lt;/p&gt;</content><author><name>Nadav Geva</name></author><category term="memory" /><category term="dx12" /><summary type="html">Ever wondered why the DirectX offers two seemingly interchangeable buffer types? In this post we’ll go over the subtleties of the two. The MSDN does contain this information, but it is scattered across several pages that only vaguely link each other.</summary></entry><entry><title type="html">Welcome to Dark Corners of the API!</title><link href="http://localhost:4000/welcome-to-dark-corners" rel="alternate" type="text/html" title="Welcome to Dark Corners of the API!" /><published>2022-11-15T20:00:33-05:00</published><updated>2022-11-15T20:00:33-05:00</updated><id>http://localhost:4000/welcome-to-dark-corners</id><content type="html" xml:base="http://localhost:4000/welcome-to-dark-corners">&lt;p&gt;Welcome to my new blog, Dark Corners of the API, a place to talk about corners, edge cases, and poorly documented features of graphics APIs. I’m Nadav Geva, a DevTech engineer at AMD. During the course of my work helping game developers wrangle the graphics APIs, mainly DX12 and Vulkan, I’ve came across all kinds of dark corners where the helping light of the internet does not go. In this blog, I hope to shed some of that light so hopefully my suffering will spare yours.&lt;/p&gt;</content><author><name>Nadav Geva</name></author><category term="announcement" /><summary type="html">Welcome to my new blog, Dark Corners of the API, a place to talk about corners, edge cases, and poorly documented features of graphics APIs. I’m Nadav Geva, a DevTech engineer at AMD. During the course of my work helping game developers wrangle the graphics APIs, mainly DX12 and Vulkan, I’ve came across all kinds of dark corners where the helping light of the internet does not go. In this blog, I hope to shed some of that light so hopefully my suffering will spare yours.</summary></entry></feed>